// This file is auto-generated by DesignPaser.py. Manual edits will be lost on regeneration.
// Last generated on Sun Nov 28 17:33:03 2010
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;

namespace SpacecraftGT
{
    public abstract partial class Packet
    {
        public abstract byte[] Save();
        public static Packet Load(byte[] data)
        {
			Packet Output = null;
			int BufferPos = 0;
			switch (data[0]) {
				case 0x0: { //KeepAlive
					var Packet = Output as KeepAlivePacket;
					Packet = new KeepAlivePacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					break; }

				case 0x1: { //LoginRequest
					var Packet = Output as LoginRequestPacket;
					Packet = new LoginRequestPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.ProtocolVersion = GetNextInt(data, ref BufferPos);
					Packet.Username = GetNextString(data, ref BufferPos);
					Packet.Password = GetNextString(data, ref BufferPos);
					Packet.MapSeed = GetNextLong(data, ref BufferPos);
					Packet.Dimension = GetNextByte(data, ref BufferPos);
					break; }

				case 0x2: { //Handshake
					var Packet = Output as HandshakePacket;
					Packet = new HandshakePacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Username = GetNextString(data, ref BufferPos);
					break; }

				case 0x3: { //ChatMessage
					var Packet = Output as ChatMessagePacket;
					Packet = new ChatMessagePacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Message = GetNextString(data, ref BufferPos);
					break; }

				case 0x5: { //PlayerInventory
					var Packet = Output as PlayerInventoryPacket;
					Packet = new PlayerInventoryPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Type = GetNextInt(data, ref BufferPos);
					Packet.Count = GetNextShort(data, ref BufferPos);
					Packet.Payload = GetNextByteArray(data, ref BufferPos);
					break; }

				case 0x7: { //UseEntity
					var Packet = Output as UseEntityPacket;
					Packet = new UseEntityPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.User = GetNextInt(data, ref BufferPos);
					Packet.Target = GetNextInt(data, ref BufferPos);
					Packet.Punching = GetNextBool(data, ref BufferPos);
					break; }

				case 0x9: { //Respawn
					var Packet = Output as RespawnPacket;
					Packet = new RespawnPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Unknown = GetNextByte(data, ref BufferPos);
					break; }

				case 0xa: { //Player
					var Packet = Output as PlayerPacket;
					Packet = new PlayerPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.OnGround = GetNextBool(data, ref BufferPos);
					break; }

				case 0xb: { //PlayerPosition
					var Packet = Output as PlayerPositionPacket;
					Packet = new PlayerPositionPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.X = GetNextDouble(data, ref BufferPos);
					Packet.Y = GetNextDouble(data, ref BufferPos);
					Packet.Stance = GetNextDouble(data, ref BufferPos);
					Packet.Z = GetNextDouble(data, ref BufferPos);
					Packet.OnGround = GetNextBool(data, ref BufferPos);
					break; }

				case 0xc: { //PlayerLook
					var Packet = Output as PlayerLookPacket;
					Packet = new PlayerLookPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Yaw = GetNextFloat(data, ref BufferPos);
					Packet.Pitch = GetNextFloat(data, ref BufferPos);
					Packet.OnGround = GetNextBool(data, ref BufferPos);
					break; }

				case 0xd: { //PlayerPositionLook
					var Packet = Output as PlayerPositionLookPacket;
					Packet = new PlayerPositionLookPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.X = GetNextDouble(data, ref BufferPos);
					Packet.Y = GetNextDouble(data, ref BufferPos);
					Packet.Stance = GetNextDouble(data, ref BufferPos);
					Packet.Z = GetNextDouble(data, ref BufferPos);
					Packet.Yaw = GetNextFloat(data, ref BufferPos);
					Packet.Pitch = GetNextFloat(data, ref BufferPos);
					Packet.OnGround = GetNextBool(data, ref BufferPos);
					break; }

				case 0xe: { //PlayerDigging
					var Packet = Output as PlayerDiggingPacket;
					Packet = new PlayerDiggingPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Status = GetNextByte(data, ref BufferPos);
					Packet.X = GetNextInt(data, ref BufferPos);
					Packet.Y = GetNextByte(data, ref BufferPos);
					Packet.Z = GetNextInt(data, ref BufferPos);
					Packet.Face = GetNextByte(data, ref BufferPos);
					break; }

				case 0xf: { //PlayerBlockPlacement
					var Packet = Output as PlayerBlockPlacementPacket;
					Packet = new PlayerBlockPlacementPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.BlockItemID = GetNextShort(data, ref BufferPos);
					Packet.X = GetNextInt(data, ref BufferPos);
					Packet.Y = GetNextByte(data, ref BufferPos);
					Packet.Z = GetNextInt(data, ref BufferPos);
					Packet.Direction = GetNextByte(data, ref BufferPos);
					break; }

				case 0x10: { //HoldingChange
					var Packet = Output as HoldingChangePacket;
					Packet = new HoldingChangePacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Unused = GetNextInt(data, ref BufferPos);
					Packet.BlockItemID = GetNextShort(data, ref BufferPos);
					break; }

				case 0x12: { //ArmAnimation
					var Packet = Output as ArmAnimationPacket;
					Packet = new ArmAnimationPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.EID = GetNextInt(data, ref BufferPos);
					Packet.Animate = GetNextBool(data, ref BufferPos);
					break; }

				case 0x15: { //PickupSpawn
					var Packet = Output as PickupSpawnPacket;
					Packet = new PickupSpawnPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.EID = GetNextInt(data, ref BufferPos);
					Packet.Item = GetNextShort(data, ref BufferPos);
					Packet.Count = GetNextByte(data, ref BufferPos);
					Packet.X = GetNextInt(data, ref BufferPos);
					Packet.Y = GetNextInt(data, ref BufferPos);
					Packet.Z = GetNextInt(data, ref BufferPos);
					Packet.Rotation = GetNextByte(data, ref BufferPos);
					Packet.Pitch = GetNextByte(data, ref BufferPos);
					Packet.Roll = GetNextByte(data, ref BufferPos);
					break; }

				case 0xff: { //Disconnect
					var Packet = Output as DisconnectPacket;
					Packet = new DisconnectPacket();
					Packet.ID = GetNextByte(data, ref BufferPos);
					Packet.Reason = GetNextString(data, ref BufferPos);
					break; }

			}
			return Output;
		}
	}
	public class KeepAlivePacket : Packet {
		public byte ID = 0x0;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			return Build.ToArray();
		}
	}

	public class LoginRequestPacket : Packet {
		public byte ID = 0x1;
		public int ProtocolVersion;
		public string Username;
		public string Password;
		public long MapSeed;
		public byte Dimension;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( ProtocolVersion ).ToBytes() );
			Build.Append(  Username.ToBytes() );
			Build.Append(  Password.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( MapSeed ).ToBytes() );
			Build.Append(  Dimension.ToBytes() );
			return Build.ToArray();
		}
	}

	public class HandshakePacket : Packet {
		public byte ID = 0x2;
		public string Username;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  Username.ToBytes() );
			return Build.ToArray();
		}
	}

	public class ChatMessagePacket : Packet {
		public byte ID = 0x3;
		public string Message;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  Message.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerInventoryPacket : Packet {
		public byte ID = 0x5;
		public int Type;
		public short Count;
		public byte[] Payload;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Type ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Count ).ToBytes() );
			Build.Append(  Payload.ToBytes() );
			return Build.ToArray();
		}
	}

	public class UseEntityPacket : Packet {
		public byte ID = 0x7;
		public int User;
		public int Target;
		public bool Punching;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( User ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Target ).ToBytes() );
			Build.Append(  Punching.ToBytes() );
			return Build.ToArray();
		}
	}

	public class RespawnPacket : Packet {
		public byte ID = 0x9;
		public byte Unknown;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  Unknown.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerPacket : Packet {
		public byte ID = 0xa;
		public bool OnGround;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  OnGround.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerPositionPacket : Packet {
		public byte ID = 0xb;
		public double X;
		public double Y;
		public double Stance;
		public double Z;
		public bool OnGround;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  X.ToBytes() );
			Build.Append(  Y.ToBytes() );
			Build.Append(  Stance.ToBytes() );
			Build.Append(  Z.ToBytes() );
			Build.Append(  OnGround.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerLookPacket : Packet {
		public byte ID = 0xc;
		public float Yaw;
		public float Pitch;
		public bool OnGround;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  Yaw.ToBytes() );
			Build.Append(  Pitch.ToBytes() );
			Build.Append(  OnGround.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerPositionLookPacket : Packet {
		public byte ID = 0xd;
		public double X;
		public double Y;
		public double Stance;
		public double Z;
		public float Yaw;
		public float Pitch;
		public bool OnGround;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  X.ToBytes() );
			Build.Append(  Y.ToBytes() );
			Build.Append(  Stance.ToBytes() );
			Build.Append(  Z.ToBytes() );
			Build.Append(  Yaw.ToBytes() );
			Build.Append(  Pitch.ToBytes() );
			Build.Append(  OnGround.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerDiggingPacket : Packet {
		public byte ID = 0xe;
		public byte Status;
		public int X;
		public byte Y;
		public int Z;
		public byte Face;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  Status.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( X ).ToBytes() );
			Build.Append(  Y.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Z ).ToBytes() );
			Build.Append(  Face.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PlayerBlockPlacementPacket : Packet {
		public byte ID = 0xf;
		public short BlockItemID;
		public int X;
		public byte Y;
		public int Z;
		public byte Direction;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( BlockItemID ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( X ).ToBytes() );
			Build.Append(  Y.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Z ).ToBytes() );
			Build.Append(  Direction.ToBytes() );
			return Build.ToArray();
		}
	}

	public class HoldingChangePacket : Packet {
		public byte ID = 0x10;
		public int Unused;
		public short BlockItemID;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Unused ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( BlockItemID ).ToBytes() );
			return Build.ToArray();
		}
	}

	public class ArmAnimationPacket : Packet {
		public byte ID = 0x12;
		public int EID;
		public bool Animate;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( EID ).ToBytes() );
			Build.Append(  Animate.ToBytes() );
			return Build.ToArray();
		}
	}

	public class PickupSpawnPacket : Packet {
		public byte ID = 0x15;
		public int EID;
		public short Item;
		public byte Count;
		public int X;
		public int Y;
		public int Z;
		public byte Rotation;
		public byte Pitch;
		public byte Roll;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( EID ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Item ).ToBytes() );
			Build.Append(  Count.ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( X ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Y ).ToBytes() );
			Build.Append( IPAddress.HostToNetworkOrder( Z ).ToBytes() );
			Build.Append(  Rotation.ToBytes() );
			Build.Append(  Pitch.ToBytes() );
			Build.Append(  Roll.ToBytes() );
			return Build.ToArray();
		}
	}

	public class DisconnectPacket : Packet {
		public byte ID = 0xff;
		public string Reason;

		public override byte[] Save() { 
			Builder<Byte> Build = new Builder<byte>();
			Build.Append(  ID.ToBytes() );
			Build.Append(  Reason.ToBytes() );
			return Build.ToArray();
		}
	}

}
